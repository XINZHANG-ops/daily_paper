
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025-05-28 Papers</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #4d4042;
            background-image: url('bg.png');
            background-size: auto;
            background-repeat: repeat;
            overflow-x: hidden;
        }
        h1 {
            color: #333;
        }
        .paper-container {
            position: relative;
            display: flex;
            margin-bottom: 30px;
            justify-content: space-between;
            max-width: 100%;
            transition: all 0.3s ease;
        }
        
        /* 卡片容器样式 - 新增 */
        .card-deck {
            width: 100%;
            position: relative;
            margin-right: 20px;
            height: 600px; /* 固定高度 */
            cursor: pointer; /* 增加指针样式提示可点击 */
        }
        
        /* 卡片通用样式 */
        .paper-card {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            transition: all 0.3s ease;
            background-size: auto;
            background-repeat: repeat;
            background-position: center;
            background: linear-gradient(rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.5)), url('');
            background-blend-mode: overlay;
            overflow-wrap: break-word;
        }
        
        /* 轮播卡片样式 - 新增 */
        .card-deck .paper-card {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            box-sizing: border-box;
            height: 100%;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        
        /* 非激活卡片的样式 - 新增 */
        .card-deck .paper-card:not(.active) {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
        }
        
        /* 激活卡片的样式 - 新增 */
        .card-deck .paper-card.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
            z-index: 1;
        }
        
        /* 第一张卡片（文本内容）不需要滚动 */
        .card-deck .paper-card:first-child {
            overflow-y: auto;
        }

        .card-deck .paper-card:first-child:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        /* 第二张卡片（流程图）支持滚动 */
        .flowchart-card {
            text-align: center;
            background-color: #fff !important;
            overflow: auto !important;
            padding-bottom: 50px; /* 添加底部填充 */
        }

        .flowchart-card svg {
            width: 100%;
            height: auto;
            max-height: none; /* 移除任何高度限制 */
        }
        
        /* 传统卡片样式 */
        .paper-container > .paper-card {
            width: 100%;
            margin-right: 20px;
        }
        
        .paper-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .paper-card h2 {
            margin: 0 0 10px;
            font-size: 1.2em;
        }
        
        .paper-card p {
            margin: 5px 0;
        }
        
        .paper-card a {
            color: #1a73e8;
            text-decoration: none;
        }
        
        .paper-card a:hover {
            text-decoration: underline;
        }
        
        .category-chunk {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .category-chunk:hover {
            transform: translateY(-3px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
        }
        
        .category-chunk:nth-child(1) {
            background-color: #d3e3fd;
        }
        
        .category-chunk:nth-child(2) {
            background-color: #e6d6fa;
        }
        
        .category-chunk:nth-child(3) {
            background-color: #d4f8d9;
        }
        
        .category-chunk:nth-child(4) {
            background-color: #ffd7d5;
        }
        
        .category-chunk:nth-child(5) {
            background-color: #d3e3fd;
        }
        
        /* 卡片计数器 - 新增 */
        .card-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            z-index: 2;
        }

        /* Quiz tabs and popup styles */
        .quiz-tabs {
            display: flex;
            flex-direction: column;
            position: sticky;
            top: 20px;
            align-self: flex-start;
            width: fit-content;
            min-width: 50px;
            margin-left: auto;
        }
        .quiz-tab {
            width: 50px;
            height: 50px;
            background-color: #1a73e8;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            cursor: pointer;
            position: relative;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 10;
        }
        .quiz-tab:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .quiz-popup {
            position: fixed; /* 改为固定定位，不随滚动而移动 */
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%); /* 居中显示 */
            width: 90%;
            max-width: 500px; /* 增加最大宽度，适应长内容 */
            max-height: 80vh; /* 限制最大高度 */
            overflow-y: auto; /* 内容过多时可滚动 */
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 9999; /* 确保显示在最上层 */
        }
        
        /* 添加遮罩层，防止问题卡被其他内容遮挡 */
        .popup-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            display: none;
        }
        
        .popup-backdrop.active {
            display: block;
        }
        /* 使用JavaScript控制问题卡的显示和隐藏，不再使用hover */
        .quiz-popup.active {
            display: block;
        }
        .quiz-question {
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
            font-size: 18px;
            line-height: 1.5;
            word-wrap: break-word; /* 确保长单词自动换行 */
            overflow-wrap: break-word;
            hyphens: auto; /* 在必要时使用连字符 */
        }
        .quiz-choices {
            display: flex;
            flex-direction: column;
        }
        .quiz-choice {
            padding: 12px 15px;
            margin: 8px 0;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            color: #333;
            font-size: 15px;
            background-color: #f9f9f9;
            word-wrap: break-word; /* 确保长单词自动换行 */
            overflow-wrap: break-word;
            line-height: 1.4;
            text-align: left; /* 长文本左对齐 */
            display: block; /* 确保是块级元素 */
            white-space: normal; /* 允许自动换行 */
        }
        .quiz-choice:hover {
            background-color: #f0f0f0;
        }
        .quiz-choice.selected {
            background-color: #d3e3fd;
            border-color: #1a73e8;
        }
        .quiz-choice.correct {
            background-color: #d4f8d9;
            border-color: #0f9d58;
        }
        .quiz-choice.incorrect {
            background-color: #ffd7d5;
            border-color: #d93025;
        }
        .quiz-feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            display: none;
            font-weight: bold;
            text-align: center;
        }
        .quiz-feedback.correct {
            background-color: #d4f8d9;
            color: #0f9d58;
            display: block;
            border: 1px solid #0f9d58;
        }
        .quiz-feedback.incorrect {
            background-color: #ffd7d5;
            color: #d93025;
            display: block;
            border: 1px solid #d93025;
        }
        
        /* 长文本选项的特殊样式 */
        .quiz-choice.long-text {
            font-size: 13px;
            line-height: 1.3;
            padding: 10px 12px;
        }
        
        /* 确保弹窗中的按钮文本不会溢出 */
        .quiz-choice button,
        .quiz-choice a {
            word-break: break-word;
            white-space: normal;
            text-align: left;
            width: 100%;
        }
        
        /* 适应超长选项文本 */
        @media (max-width: 500px) {
            .quiz-popup {
                width: 95%;
                padding: 12px;
            }
            .quiz-question {
                font-size: 15px;
                margin-bottom: 12px;
            }
            .quiz-choice {
                padding: 8px 10px;
                font-size: 13px;
                line-height: 1.3;
            }
            .quiz-feedback {
                font-size: 13px;
                padding: 8px;
            }
        }
        
        @media (max-width: 768px) {
            .paper-container {
                flex-direction: column;
            }
            
            .card-deck {
                margin-right: 0;
                margin-bottom: 40px;
                height: 650px; /* 移动设备上高度调整 */
            }
            
            .paper-container > .paper-card {
                width: 100% !important;
                margin-bottom: 20px;
                margin-right: 0;
            }
            
            .quiz-tabs {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: flex-start;
                position: relative;
                margin-left: 0;
            }
            .quiz-tab {
                margin-right: 10px;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>2025-05-28 Papers</h1>
    
            <div class="paper-container">
                <div class="card-deck">
                    <!-- 卡片计数器 -->
                    <div class="card-counter">1/2</div>
                    
                    <!-- 第一张卡片：论文概述 -->
                    <div class="paper-card active" style="background-image: url('bg/diagmonds.png');">
                        <h2 style="color: #ffffff;">Paper 1</h2>
                        <p style="color: #badb12;"><strong>UI-Genie: A Self-Improving Approach for Iteratively Boosting MLLM-based
  Mobile GUI Agents</strong></p>
                        <p style="color: #ffffff;"><strong>Published: </strong>2025-05-27</p>
                        <p><strong>Link: </strong><a href="http://arxiv.org/pdf/2505.21496" target="_blank">http://arxiv.org/pdf/2505.21496</a></p>
                        <div><div class="category-chunk">1.  <strong>📘 Topic and Domain:</strong> The paper presents UI-Genie, a self-improving framework for mobile GUI agents using multimodal large language models (MLLMs) to automate mobile interface interactions.</div><div class="category-chunk">2.  <strong>💡 Previous Research and New Ideas:</strong> Based on previous MLLM research for GUI agents, it introduces a novel self-improving approach with a specialized reward model and automatic trajectory generation, eliminating reliance on manual annotation.</div><div class="category-chunk">3.  <strong>❓ Problem:</strong> The paper addresses two key challenges in GUI agents: the difficulty of verifying trajectory outcomes and the lack of scalable high-quality training data.</div><div class="category-chunk">4.  <strong>🛠️ Methods:</strong> The authors developed UI-Genie-RM (a specialized reward model), generated synthetic training data through rule-based verification and trajectory corruption, and implemented an iterative self-improvement pipeline where both agent and reward models evolve together.</div><div class="category-chunk">5.  <strong>📊 Results and Evaluation:</strong> UI-Genie achieved state-of-the-art performance across multiple GUI agent benchmarks after three generations of self-improvement, while generating two novel datasets (UI-Genie-RM-517k and UI-Genie-Agent-16k) without manual annotation.</div></div>
                    </div>
                    
                    <!-- 第二张卡片：流程图 -->
                    <div class="paper-card flowchart-card" style="background-color: white;">
                        <h2>UI-Genie: A Self-Improving Approach for Iteratively Boosting MLLM-based
  Mobile GUI Agents</h2>
                        <svg width="100%" viewBox="0 0 1000 800">
    <!-- Background -->
    <rect x="0" y="0" width="1000" height="800" fill="#f8f9fa"/>
    
    <!-- Title -->
    <text x="500" y="50" font-size="24" font-weight="bold" text-anchor="middle" fill="#2c3e50">UI-Genie Framework</text>

    <!-- Main Components -->
    <g transform="translate(0,20)">
        <!-- UI-Genie-RM -->
        <rect x="100" y="100" width="200" height="100" rx="10" fill="#3498db" opacity="0.8"/>
        <text x="200" y="150" font-size="16" fill="white" text-anchor="middle">UI-Genie-RM</text>
        <text x="200" y="170" font-size="12" fill="white" text-anchor="middle">Reward Model</text>

        <!-- Training Data Construction -->
        <rect x="400" y="100" width="200" height="100" rx="10" fill="#e74c3c" opacity="0.8"/>
        <text x="500" y="140" font-size="16" fill="white" text-anchor="middle">Training Data</text>
        <text x="500" y="160" font-size="12" fill="white" text-anchor="middle">Construction</text>

        <!-- UI-Genie-Agent -->
        <rect x="700" y="100" width="200" height="100" rx="10" fill="#2ecc71" opacity="0.8"/>
        <text x="800" y="150" font-size="16" fill="white" text-anchor="middle">UI-Genie-Agent</text>

        <!-- Self-Improvement Pipeline -->
        <rect x="250" y="300" width="500" height="120" rx="10" fill="#9b59b6" opacity="0.8"/>
        <text x="500" y="340" font-size="18" fill="white" text-anchor="middle">Self-Improvement Pipeline</text>
        <text x="500" y="370" font-size="12" fill="white" text-anchor="middle">Trajectory Exploration + Outcome Verification</text>
        <text x="500" y="390" font-size="12" fill="white" text-anchor="middle">Dataset Expansion + Model Fine-tuning</text>

        <!-- Generated Datasets -->
        <rect x="150" y="500" width="300" height="80" rx="10" fill="#f1c40f" opacity="0.8"/>
        <text x="300" y="540" font-size="16" fill="white" text-anchor="middle">UI-Genie-RM-517k</text>
        <text x="300" y="560" font-size="12" fill="white" text-anchor="middle">Reward Dataset</text>

        <rect x="550" y="500" width="300" height="80" rx="10" fill="#f1c40f" opacity="0.8"/>
        <text x="700" y="540" font-size="16" fill="white" text-anchor="middle">UI-Genie-Agent-16k</text>
        <text x="700" y="560" font-size="12" fill="white" text-anchor="middle">Synthetic Trajectory Dataset</text>

        <!-- Connecting Lines -->
        <path d="M300 200 L500 300" stroke="#34495e" stroke-width="2" fill="none"/>
        <path d="M500 200 L500 300" stroke="#34495e" stroke-width="2" fill="none"/>
        <path d="M700 200 L500 300" stroke="#34495e" stroke-width="2" fill="none"/>
        
        <path d="M300 420 L300 500" stroke="#34495e" stroke-width="2" fill="none"/>
        <path d="M700 420 L700 500" stroke="#34495e" stroke-width="2" fill="none"/>
    </g>

    <!-- Method Steps -->
    <g transform="translate(50, 650)">
        <circle cx="100" cy="50" r="20" fill="#3498db"/>
        <text x="100" y="55" font-size="14" fill="white" text-anchor="middle">1</text>
        <text x="140" y="55" font-size="12" fill="#34495e">Build Reward Model</text>

        <circle cx="300" cy="50" r="20" fill="#e74c3c"/>
        <text x="300" y="55" font-size="14" fill="white" text-anchor="middle">2</text>
        <text x="340" y="55" font-size="12" fill="#34495e">Generate Training Data</text>

        <circle cx="500" cy="50" r="20" fill="#9b59b6"/>
        <text x="500" y="55" font-size="14" fill="white" text-anchor="middle">3</text>
        <text x="540" y="55" font-size="12" fill="#34495e">Self-Improvement</text>

        <circle cx="700" cy="50" r="20" fill="#2ecc71"/>
        <text x="700" y="55" font-size="14" fill="white" text-anchor="middle">4</text>
        <text x="740" y="55" font-size="12" fill="#34495e">Train Agent Model</text>
    </g>
</svg>
                    </div>
                </div>
                <div class="quiz-tabs">
                <div class="quiz-tab" title="Click To Open Question #1">Q1
                    <div class="quiz-popup" data-answer="It eliminates the need for manual annotation through self-improvement">
                        <div class="quiz-question">1. What is the main innovation of UI-Genie compared to previous GUI agent approaches?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="It uses a larger language model">It uses a larger language model</div><div class="quiz-choice" data-value="It eliminates the need for manual annotation through self-improvement">It eliminates the need for manual annotation through self-improvement</div><div class="quiz-choice" data-value="It only works with Android devices">It only works with Android devices</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #2">Q2
                    <div class="quiz-popup" data-answer="It uses the 5 most recent screenshots plus summarized earlier actions">
                        <div class="quiz-question">2. How does UI-Genie-RM process historical context to evaluate actions?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="It only looks at the current screenshot">It only looks at the current screenshot</div><div class="quiz-choice" data-value="It uses the full history of all screenshots">It uses the full history of all screenshots</div><div class="quiz-choice" data-value="It uses the 5 most recent screenshots plus summarized earlier actions">It uses the 5 most recent screenshots plus summarized earlier actions</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #3">Q3
                    <div class="quiz-popup" data-answer="517,000 samples">
                        <div class="quiz-question">3. What is the size of the synthetic reward dataset (UI-Genie-RM) created by this framework?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="16,000 samples">16,000 samples</div><div class="quiz-choice" data-value="517,000 samples">517,000 samples</div><div class="quiz-choice" data-value="1 million samples">1 million samples</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                </div>
            </div>
            
            <div class="paper-container">
                <div class="card-deck">
                    <!-- 卡片计数器 -->
                    <div class="card-counter">1/2</div>
                    
                    <!-- 第一张卡片：论文概述 -->
                    <div class="paper-card active" style="background-image: url('bg/black-paper.png');">
                        <h2 style="color: #ffffff;">Paper 2</h2>
                        <p style="color: #badb12;"><strong>Exploring the Latent Capacity of LLMs for One-Step Text Generation</strong></p>
                        <p style="color: #ffffff;"><strong>Published: </strong>2025-05-27</p>
                        <p><strong>Link: </strong><a href="http://arxiv.org/pdf/2505.21189" target="_blank">http://arxiv.org/pdf/2505.21189</a></p>
                        <div><div class="category-chunk">1.  <strong>📘 Topic and Domain:</strong> Exploring large language models' ability to generate text in a single forward pass using specially trained input embeddings, in the domain of natural language processing and neural architectures.</div><div class="category-chunk">2.  <strong>💡 Previous Research and New Ideas:</strong> Based on research showing LLMs can reconstruct text autoregressively from trained embeddings, this paper proposes non-autoregressive generation using just two trainable "proto-tokens."</div><div class="category-chunk">3.  <strong>❓ Problem:</strong> The paper investigates whether LLMs can generate accurate multi-token sequences in one forward pass without iterative decoding, challenging the assumption that autoregressive generation is necessary.</div><div class="category-chunk">4.  <strong>🛠️ Methods:</strong> Uses two trainable embeddings ("proto-tokens") fed into frozen LLMs, optimizing them to generate target sequences in a single pass, with one token shared across texts and the other unique to each text.</div><div class="category-chunk">5.  <strong>📊 Results and Evaluation:</strong> Successfully generated hundreds of accurate tokens in one forward pass (up to 724 tokens for largest models), achieving 279x faster generation than autoregressive methods, though with approximately half the maximum sequence length capacity.</div></div>
                    </div>
                    
                    <!-- 第二张卡片：流程图 -->
                    <div class="paper-card flowchart-card" style="background-color: white;">
                        <h2>Exploring the Latent Capacity of LLMs for One-Step Text Generation</h2>
                        <svg width="100%" viewBox="0 0 1000 800">
    <defs>
        <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#4B79A1;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#283E51;stop-opacity:1" />
        </linearGradient>
    </defs>
    
    <!-- Title -->
    <rect x="350" y="20" width="300" height="60" rx="10" fill="url(#grad1)"/>
    <text x="500" y="55" text-anchor="middle" fill="white" font-size="16">One-Step Text Generation with LLMs</text>
    
    <!-- Input Section -->
    <rect x="100" y="150" width="200" height="80" rx="10" fill="#A8E6CF"/>
    <text x="200" y="180" text-anchor="middle" font-size="14">Input:</text>
    <text x="200" y="200" text-anchor="middle" font-size="14">Two "Proto-tokens"</text>
    <text x="200" y="220" text-anchor="middle" font-size="12">(e and m tokens)</text>

    <!-- Model Section -->
    <rect x="400" y="150" width="200" height="80" rx="10" fill="#FFB6B9"/>
    <text x="500" y="190" text-anchor="middle" font-size="14">Frozen Pre-trained LLM</text>
    
    <!-- Output Section -->
    <rect x="700" y="150" width="200" height="80" rx="10" fill="#BDEAEE"/>
    <text x="800" y="190" text-anchor="middle" font-size="14">Generated Text Sequence</text>

    <!-- Key Findings -->
    <rect x="150" y="300" width="700" height="400" rx="15" fill="#F8F9FA" stroke="#DDD"/>
    <text x="500" y="340" text-anchor="middle" font-size="16" fill="#333">Key Findings</text>
    
    <rect x="180" y="380" width="300" height="60" rx="8" fill="#E8F4F9"/>
    <text x="330" y="415" text-anchor="middle" font-size="12">Can generate hundreds of tokens</text>
    <text x="330" y="430" text-anchor="middle" font-size="12">in single forward pass</text>

    <rect x="520" y="380" width="300" height="60" rx="8" fill="#E8F4F9"/>
    <text x="670" y="415" text-anchor="middle" font-size="12">Two tokens are essential</text>
    <text x="670" y="430" text-anchor="middle" font-size="12">one token setup fails</text>

    <rect x="180" y="460" width="300" height="60" rx="8" fill="#E8F4F9"/>
    <text x="330" y="495" text-anchor="middle" font-size="12">Token arrangement matters</text>
    <text x="330" y="510" text-anchor="middle" font-size="12">[e][m]×(N-1) works best</text>

    <rect x="520" y="460" width="300" height="60" rx="8" fill="#E8F4F9"/>
    <text x="670" y="495" text-anchor="middle" font-size="12">279× faster than</text>
    <text x="670" y="510" text-anchor="middle" font-size="12">autoregressive generation</text>

    <rect x="180" y="540" width="300" height="60" rx="8" fill="#E8F4F9"/>
    <text x="330" y="575" text-anchor="middle" font-size="12">Works better with natural text</text>
    <text x="330" y="590" text-anchor="middle" font-size="12">vs random sequences</text>

    <rect x="520" y="540" width="300" height="60" rx="8" fill="#E8F4F9"/>
    <text x="670" y="575" text-anchor="middle" font-size="12">Solutions form connected</text>
    <text x="670" y="590" text-anchor="middle" font-size="12">regions in embedding space</text>

    <!-- Connecting Lines -->
    <line x1="300" y1="190" x2="400" y2="190" stroke="#666" stroke-width="2"/>
    <line x1="600" y1="190" x2="700" y2="190" stroke="#666" stroke-width="2"/>
</svg>
                    </div>
                </div>
                <div class="quiz-tabs">
                <div class="quiz-tab" title="Click To Open Question #1">Q1
                    <div class="quiz-popup" data-answer="Using two specially trained proto-tokens in one forward pass">
                        <div class="quiz-question">1. What is the key innovation in the paper's text generation approach compared to traditional methods?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="Using a single trainable token for generation">Using a single trainable token for generation</div><div class="quiz-choice" data-value="Using two specially trained proto-tokens in one forward pass">Using two specially trained proto-tokens in one forward pass</div><div class="quiz-choice" data-value="Using multiple forward passes with shared embeddings">Using multiple forward passes with shared embeddings</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #2">Q2
                    <div class="quiz-popup" data-answer="One proto-token can be shared across multiple texts while maintaining performance">
                        <div class="quiz-question">2. What surprising finding did the researchers discover about the proto-tokens?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="They only work with large language models">They only work with large language models</div><div class="quiz-choice" data-value="They must be completely unique for each text">They must be completely unique for each text</div><div class="quiz-choice" data-value="One proto-token can be shared across multiple texts while maintaining performance">One proto-token can be shared across multiple texts while maintaining performance</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #3">Q3
                    <div class="quiz-popup" data-answer="About 279 times faster">
                        <div class="quiz-question">3. How does the speed improvement of this method compare to traditional autoregressive generation?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="About 279 times faster">About 279 times faster</div><div class="quiz-choice" data-value="About 50 times faster">About 50 times faster</div><div class="quiz-choice" data-value="About 100 times faster">About 100 times faster</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                </div>
            </div>
            
            <div class="paper-container">
                <div class="card-deck">
                    <!-- 卡片计数器 -->
                    <div class="card-counter">1/2</div>
                    
                    <!-- 第一张卡片：论文概述 -->
                    <div class="paper-card active" style="background-image: url('bg/dark-geometric.png');">
                        <h2 style="color: #ffffff;">Paper 3</h2>
                        <p style="color: #badb12;"><strong>MME-VideoOCR: Evaluating OCR-Based Capabilities of Multimodal LLMs in
  Video Scenarios</strong></p>
                        <p style="color: #ffffff;"><strong>Published: </strong>2025-05-27</p>
                        <p><strong>Link: </strong><a href="http://arxiv.org/pdf/2505.21333" target="_blank">http://arxiv.org/pdf/2505.21333</a></p>
                        <div><div class="category-chunk">1.  <strong>📘 Topic and Domain:</strong> The paper focuses on evaluating Optical Character Recognition (OCR) capabilities of Multimodal Large Language Models (MLLMs) in video scenarios.</div><div class="category-chunk">2.  <strong>💡 Previous Research and New Ideas:</strong> Previous research mainly focused on OCR in static images, while this paper introduces a comprehensive benchmark for video OCR tasks and proposes new evaluation methods for dynamic text recognition.</div><div class="category-chunk">3.  <strong>❓ Problem:</strong> The paper addresses the challenge of evaluating MLLMs' ability to recognize, understand, and reason about text in videos, which is more complex than static image OCR due to motion blur, temporal variations, and visual effects.</div><div class="category-chunk">4.  <strong>🛠️ Methods:</strong> The authors created MME-VideoOCR benchmark with 1,464 videos and 2,000 manually annotated question-answer pairs across 25 tasks in 10 categories, evaluating 18 state-of-the-art MLLMs using containment match, GPT-assisted scoring, and multiple-choice evaluation methods.</div><div class="category-chunk">5.  <strong>📊 Results and Evaluation:</strong> The best-performing model (Gemini-2.5 Pro) achieved 73.7% accuracy, while most models struggled with tasks requiring spatio-temporal reasoning and cross-frame information integration, highlighting the need for improved video OCR capabilities in MLLMs.</div></div>
                    </div>
                    
                    <!-- 第二张卡片：流程图 -->
                    <div class="paper-card flowchart-card" style="background-color: white;">
                        <h2>MME-VideoOCR: Evaluating OCR-Based Capabilities of Multimodal LLMs in
  Video Scenarios</h2>
                        <svg width="100%" viewBox="0 0 1000 800">
  <!-- Background -->
  <rect width="100%" height="100%" fill="#f5f5f5"/>
  
  <!-- Title -->
  <text x="500" y="50" text-anchor="middle" font-size="24" font-weight="bold" fill="#333">MME-VideoOCR Workflow</text>

  <!-- Data Collection Box -->
  <rect x="100" y="100" width="200" height="100" rx="10" fill="#4CAF50" opacity="0.8"/>
  <text x="200" y="150" text-anchor="middle" fill="white" font-size="16">Data Collection
    <tspan x="200" y="170" font-size="12">Public Videos</tspan>
    <tspan x="200" y="185" font-size="12">AI Generated Videos</tspan>
  </text>

  <!-- Video Filtering Box -->
  <rect x="400" y="100" width="200" height="100" rx="10" fill="#2196F3" opacity="0.8"/>
  <text x="500" y="150" text-anchor="middle" fill="white" font-size="16">Video Filtering
    <tspan x="500" y="170" font-size="12">Visual Dynamics</tspan>
    <tspan x="500" y="185" font-size="12">Meaningful Text</tspan>
  </text>

  <!-- Manual Annotation Box -->
  <rect x="700" y="100" width="200" height="100" rx="10" fill="#9C27B0" opacity="0.8"/>
  <text x="800" y="150" text-anchor="middle" fill="white" font-size="16">Manual Annotation
    <tspan x="800" y="170" font-size="12">QA Pairs Creation</tspan>
    <tspan x="800" y="185" font-size="12">Expert Verification</tspan>
  </text>

  <!-- Task Categories Box -->
  <rect x="200" y="300" width="600" height="200" rx="10" fill="#FF5722" opacity="0.8"/>
  <text x="500" y="330" text-anchor="middle" fill="white" font-size="18">Task Categories</text>
  
  <!-- Task Items -->
  <text x="250" y="370" fill="white" font-size="14">• Text Recognition</text>
  <text x="250" y="400" fill="white" font-size="14">• Visual Text QA</text>
  <text x="250" y="430" fill="white" font-size="14">• Text Grounding</text>
  <text x="250" y="460" fill="white" font-size="14">• Attribute Recognition</text>
  <text x="500" y="370" fill="white" font-size="14">• Change Detection</text>
  <text x="500" y="400" fill="white" font-size="14">• Special Text Parsing</text>
  <text x="500" y="430" fill="white" font-size="14">• Cross-Frame Understanding</text>
  <text x="500" y="460" fill="white" font-size="14">• Text-Based Reasoning</text>

  <!-- Evaluation Box -->
  <rect x="200" y="600" width="600" height="100" rx="10" fill="#795548" opacity="0.8"/>
  <text x="500" y="640" text-anchor="middle" fill="white" font-size="16">Evaluation Methods
    <tspan x="500" y="670" font-size="14">Containment Match | GPT-Assisted Scoring | Multiple-Choice</tspan>
  </text>

  <!-- Connecting Lines -->
  <line x1="300" y1="200" x2="400" y2="200" stroke="#666" stroke-width="2"/>
  <line x1="600" y1="200" x2="700" y2="200" stroke="#666" stroke-width="2"/>
  <line x1="500" y1="200" x2="500" y2="300" stroke="#666" stroke-width="2"/>
  <line x1="500" y1="500" x2="500" y2="600" stroke="#666" stroke-width="2"/>

</svg>
                    </div>
                </div>
                <div class="quiz-tabs">
                <div class="quiz-tab" title="Click To Open Question #1">Q1
                    <div class="quiz-popup" data-answer="It introduced comprehensive evaluation across temporal and spatial dimensions">
                        <div class="quiz-question">1. What was the key innovation of MME-VideoOCR compared to previous OCR benchmarks?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="It used a larger dataset of static images">It used a larger dataset of static images</div><div class="quiz-choice" data-value="It introduced comprehensive evaluation across temporal and spatial dimensions">It introduced comprehensive evaluation across temporal and spatial dimensions</div><div class="quiz-choice" data-value="It only focused on text recognition accuracy">It only focused on text recognition accuracy</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #2">Q2
                    <div class="quiz-popup" data-answer="To prevent models from relying on textual priors and knowledge leakage">
                        <div class="quiz-question">2. Why did the researchers introduce 'debiasing test' in their evaluation methodology?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="To test if models could work without visual input">To test if models could work without visual input</div><div class="quiz-choice" data-value="To prevent models from relying on textual priors and knowledge leakage">To prevent models from relying on textual priors and knowledge leakage</div><div class="quiz-choice" data-value="To evaluate models' language translation capabilities">To evaluate models' language translation capabilities</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #3">Q3
                    <div class="quiz-popup" data-answer="They struggled to integrate information across multiple frames">
                        <div class="quiz-question">3. What surprising limitation was revealed about current MLLMs through this benchmark?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="They couldn't read text at all in videos">They couldn't read text at all in videos</div><div class="quiz-choice" data-value="They performed better on long videos than short ones">They performed better on long videos than short ones</div><div class="quiz-choice" data-value="They struggled to integrate information across multiple frames">They struggled to integrate information across multiple frames</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                </div>
            </div>
            
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 创建遮罩层
            const backdrop = document.createElement('div');
            backdrop.className = 'popup-backdrop';
            document.body.appendChild(backdrop);
            
            // 获取所有问题标签
            const quizTabs = document.querySelectorAll('.quiz-tab');
            
            // 设置点击事件处理
            quizTabs.forEach(tab => {
                const popup = tab.querySelector('.quiz-popup');
                
                // 点击标签切换问题卡的显示状态
                tab.addEventListener('click', function(e) {
                    e.stopPropagation(); // 阻止事件冒泡
                    
                    // 如果当前问题卡已经显示，则隐藏它
                    if (popup.classList.contains('active')) {
                        popup.classList.remove('active');
                        backdrop.classList.remove('active');
                    } else {
                        // 先隐藏所有其他问题卡
                        document.querySelectorAll('.quiz-popup').forEach(p => {
                            p.classList.remove('active');
                        });
                        
                        // 将弹窗内容复制到页面最外层的弹窗中
                        document.body.appendChild(popup);
                        
                        // 显示当前问题卡和背景遮罩
                        popup.classList.add('active');
                        backdrop.classList.add('active');
                    }
                });
                
                // 确保点击问题卡内部时不会关闭问题卡
                popup.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            });
            
            // 点击遮罩层或页面任何其他位置时隐藏所有问题卡
            backdrop.addEventListener('click', closeAllPopups);
            document.addEventListener('click', closeAllPopups);
            
            function closeAllPopups() {
                document.querySelectorAll('.quiz-popup').forEach(popup => {
                    popup.classList.remove('active');
                });
                backdrop.classList.remove('active');
            }
            
            // 为每个选项添加点击事件
            document.querySelectorAll('.quiz-choice').forEach(choice => {
                choice.addEventListener('click', function() {
                    const choiceContainer = this.closest('.quiz-choices');
                    const popupContainer = this.closest('.quiz-popup');
                    const feedbackElement = popupContainer.querySelector('.quiz-feedback');
                    const correctAnswer = popupContainer.getAttribute('data-answer');
                    
                    // 重置所有选项
                    choiceContainer.querySelectorAll('.quiz-choice').forEach(c => {
                        c.classList.remove('selected', 'correct', 'incorrect');
                    });
                    
                    // 标记当前选项为已选
                    this.classList.add('selected');
                    
                    // 检查是否正确
                    if (this.getAttribute('data-value') === correctAnswer) {
                        this.classList.add('correct');
                        feedbackElement.textContent = '✔️ Correct！';
                        feedbackElement.classList.add('correct');
                        feedbackElement.classList.remove('incorrect');
                    } else {
                        this.classList.add('incorrect');
                        feedbackElement.textContent = '❌ Wrong！';
                        feedbackElement.classList.add('incorrect');
                        feedbackElement.classList.remove('correct');
                    }
                    
                    feedbackElement.style.display = 'block';
                });
            });
            
            // 卡片轮播功能 - 新增
            const cardDecks = document.querySelectorAll('.card-deck');
            
            cardDecks.forEach(cardDeck => {
                const cards = cardDeck.querySelectorAll('.paper-card');
                const counter = cardDeck.querySelector('.card-counter');
                let currentIndex = 0;
                const totalCards = cards.length;
                
                // 更新计数器显示
                function updateCounter() {
                    if (counter) {
                        counter.textContent = `${currentIndex + 1}/${totalCards}`;
                    }
                }
                
                // 显示指定索引的卡片
                function showCard(index) {
                    // 处理循环
                    if (index >= totalCards) index = 0;
                    if (index < 0) index = totalCards - 1;
                    
                    // 更新当前索引
                    currentIndex = index;
                    
                    // 更新卡片显示
                    cards.forEach((card, i) => {
                        if (i === currentIndex) {
                            card.classList.add('active');
                        } else {
                            card.classList.remove('active');
                        }
                    });
                    
                    // 更新计数器
                    updateCounter();
                }
                
                // 下一张卡片
                function nextCard(e) {
                    e.stopPropagation(); // 防止事件冒泡导致问题卡关闭
                    showCard(currentIndex + 1);
                }
                
                // 为卡片容器添加点击事件
                cardDeck.addEventListener('click', function(e) {
                    // 检查点击是否发生在流程图卡片内部的滚动区域
                    // 如果是在滚动条上点击，不切换卡片
                    const targetCard = e.target.closest('.paper-card');
                    if (targetCard && targetCard.classList.contains('flowchart-card')) {
                        // 计算点击位置是否在滚动条区域
                        const rect = targetCard.getBoundingClientRect();
                        const isScrollbarClick = 
                            (e.clientY >= rect.top && e.clientY <= rect.bottom && e.clientX >= rect.right - 20 && e.clientX <= rect.right) ||
                            (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.bottom - 20 && e.clientY <= rect.bottom);
                        
                        if (!isScrollbarClick) {
                            nextCard(e);
                        }
                    } else {
                        nextCard(e);
                    }
                });
                
                // 键盘导航
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowRight') {
                        showCard(currentIndex + 1);
                    } else if (e.key === 'ArrowLeft') {
                        showCard(currentIndex - 1);
                    }
                });
            });
        });
    </script>
</body>
</html>
