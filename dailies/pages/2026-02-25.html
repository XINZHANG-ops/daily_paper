<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026-02-25 Papers</title>
    <!-- AI Assistant Styles -->
    <link rel="stylesheet" href="../../css/ai-assistant.css">
    <style>
        * {
            box-sizing: border-box; /* Á°Æ‰øùÊâÄÊúâÂÖÉÁ¥†‰ΩøÁî®border-boxÊ®°Âûã */
        }

        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #4d4042;
            background-image: url('../../bg.png');
            background-size: auto;
            background-repeat: repeat;
            overflow-x: hidden;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        h1 {
            color: #333;
        }
        .paper-container {
            position: relative;
            display: flex;
            margin-bottom: 30px;
            justify-content: space-between;
            max-width: 100%;
            transition: all 0.3s ease;
        }
        
        /* Âç°ÁâáÂÆπÂô®Ê†∑Âºè - Êñ∞Â¢û */
        .card-deck {
            width: 100%;
            position: relative;
            margin-right: 20px;
            min-height: 600px; /* Êîπ‰∏∫ÊúÄÂ∞èÈ´òÂ∫¶ËÄå‰∏çÊòØÂõ∫ÂÆöÈ´òÂ∫¶ */
            max-height: 90vh; /* ÈôêÂà∂ÊúÄÂ§ßÈ´òÂ∫¶Èò≤Ê≠¢Ê∫¢Âá∫ */
            height: auto; /* Ëá™ÈÄÇÂ∫îÂÜÖÂÆπÈ´òÂ∫¶ */
            /* cursor removed - only cards should show pointer */
        }
        
        /* Âç°ÁâáÈÄöÁî®Ê†∑Âºè */
        .paper-card {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            transition: all 0.3s ease;
            background-size: auto;
            background-repeat: repeat;
            background-position: center;
            background: linear-gradient(rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.5)), url('');
            background-blend-mode: overlay;
            overflow-wrap: break-word;
            cursor: pointer; /* Show pointer on cards to indicate they're clickable */
        }
        
        /* ËΩÆÊí≠Âç°ÁâáÊ†∑Âºè - Êñ∞Â¢û */
        .card-deck .paper-card {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            box-sizing: border-box;
            height: 100%; /* ‰ΩøÁî®ÂÆπÂô®ÁöÑ100%È´òÂ∫¶ */
            transition: transform 0.5s ease, opacity 0.5s ease;
            overflow-y: auto; /* ÂÖÅËÆ∏ÂûÇÁõ¥ÊªöÂä® */
            overflow-x: hidden; /* Èò≤Ê≠¢Ê®™ÂêëÊªöÂä® */
        }
        
        /* ÈùûÊøÄÊ¥ªÂç°ÁâáÁöÑÊ†∑Âºè - Êñ∞Â¢û */
        .card-deck .paper-card:not(.active) {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
        }
        
        /* ÊøÄÊ¥ªÂç°ÁâáÁöÑÊ†∑Âºè - Êñ∞Â¢û */
        .card-deck .paper-card.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
            z-index: 1;
        }
        
        /* Á¨¨‰∏ÄÂº†Âç°ÁâáÔºàÊñáÊú¨ÂÜÖÂÆπÔºâ‰∏çÈúÄË¶ÅÊªöÂä® */
        .card-deck .paper-card:first-child {
            overflow-y: auto;
        }

        .card-deck .paper-card:first-child:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        /* Á¨¨‰∫åÂº†Âç°ÁâáÔºàÊµÅÁ®ãÂõæÔºâÊîØÊåÅÊªöÂä® */
        .flowchart-card {
            text-align: center;
            background-color: #fff !important;
            overflow-y: auto !important; /* ÂÖÅËÆ∏ÂûÇÁõ¥ÊªöÂä® */
            overflow-x: hidden !important; /* Èò≤Ê≠¢Ê®™ÂêëÊªöÂä® */
            padding: 20px; /* Ê∑ªÂä†ÂÜÖËæπË∑ù */
            padding-bottom: 50px; /* Ê∑ªÂä†Â∫ïÈÉ®Â°´ÂÖÖÁ°Æ‰øùËÉΩÁúãÂà∞Â∫ïÈÉ® */
        }

        .flowchart-card svg {
            width: 100%;
            height: auto;
            max-width: 100%; /* Á°Æ‰øù‰∏çË∂ÖÂá∫ÂÆπÂô®ÂÆΩÂ∫¶ */
            display: block; /* Èò≤Ê≠¢Â∫ïÈÉ®Á©∫ÁôΩ */
            margin: 0 auto; /* Â±Ö‰∏≠ÊòæÁ§∫ */
        }
        
        /* ‰º†ÁªüÂç°ÁâáÊ†∑Âºè */
        .paper-container > .paper-card {
            width: 100%;
            margin-right: 20px;
        }
        
        .paper-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .paper-card h2 {
            margin: 0 0 10px;
            font-size: 1.2em;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .paper-card p {
            margin: 5px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .paper-card a {
            color: #1a73e8;
            text-decoration: none;
        }
        
        .paper-card a:hover {
            text-decoration: underline;
        }
        
        .category-chunk {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            transition: transform 0.2s, box-shadow 0.2s;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden; /* Èò≤Ê≠¢ÂÜÖÂÆπÊ∫¢Âá∫ */
        }

        .category-chunk * {
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-width: 100%;
        }
        
        .category-chunk:hover {
            transform: translateY(-3px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
        }
        
        .category-chunk:nth-child(1) {
            background-color: #d3e3fd;
        }
        
        .category-chunk:nth-child(2) {
            background-color: #e6d6fa;
        }
        
        .category-chunk:nth-child(3) {
            background-color: #d4f8d9;
        }
        
        .category-chunk:nth-child(4) {
            background-color: #ffd7d5;
        }
        
        .category-chunk:nth-child(5) {
            background-color: #d3e3fd;
        }
        
        /* Âç°ÁâáËÆ°Êï∞Âô® - Êñ∞Â¢û */
        .card-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            z-index: 2;
        }

        /* Quiz tabs and popup styles */
        .quiz-tabs {
            display: flex;
            flex-direction: column;
            position: sticky;
            top: 20px;
            align-self: flex-start;
            width: fit-content;
            min-width: 50px;
            margin-left: auto;
        }
        .quiz-tab {
            width: 50px;
            height: 50px;
            background-color: #1a73e8;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            cursor: pointer;
            position: relative;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 10;
        }
        .quiz-tab:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .quiz-popup {
            position: fixed; /* Êîπ‰∏∫Âõ∫ÂÆöÂÆö‰ΩçÔºå‰∏çÈöèÊªöÂä®ËÄåÁßªÂä® */
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%); /* Â±Ö‰∏≠ÊòæÁ§∫ */
            width: 90%;
            max-width: 500px; /* Â¢ûÂä†ÊúÄÂ§ßÂÆΩÂ∫¶ÔºåÈÄÇÂ∫îÈïøÂÜÖÂÆπ */
            max-height: 80vh; /* ÈôêÂà∂ÊúÄÂ§ßÈ´òÂ∫¶ */
            overflow-y: auto; /* ÂÜÖÂÆπËøáÂ§öÊó∂ÂèØÊªöÂä® */
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 9999; /* Á°Æ‰øùÊòæÁ§∫Âú®ÊúÄ‰∏äÂ±Ç */
        }
        
        /* Ê∑ªÂä†ÈÅÆÁΩ©Â±ÇÔºåÈò≤Ê≠¢ÈóÆÈ¢òÂç°Ë¢´ÂÖ∂‰ªñÂÜÖÂÆπÈÅÆÊå° */
        .popup-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9998;
            display: none;
        }
        
        .popup-backdrop.active {
            display: block;
        }
        /* ‰ΩøÁî®JavaScriptÊéßÂà∂ÈóÆÈ¢òÂç°ÁöÑÊòæÁ§∫ÂíåÈöêËóèÔºå‰∏çÂÜç‰ΩøÁî®hover */
        .quiz-popup.active {
            display: block;
        }
        .quiz-question {
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
            font-size: 18px;
            line-height: 1.5;
            word-wrap: break-word; /* Á°Æ‰øùÈïøÂçïËØçËá™Âä®Êç¢Ë°å */
            overflow-wrap: break-word;
            hyphens: auto; /* Âú®ÂøÖË¶ÅÊó∂‰ΩøÁî®ËøûÂ≠óÁ¨¶ */
        }
        .quiz-choices {
            display: flex;
            flex-direction: column;
        }
        .quiz-choice {
            padding: 12px 15px;
            margin: 8px 0;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            color: #333;
            font-size: 15px;
            background-color: #f9f9f9;
            word-wrap: break-word; /* Á°Æ‰øùÈïøÂçïËØçËá™Âä®Êç¢Ë°å */
            overflow-wrap: break-word;
            line-height: 1.4;
            text-align: left; /* ÈïøÊñáÊú¨Â∑¶ÂØπÈΩê */
            display: block; /* Á°Æ‰øùÊòØÂùóÁ∫ßÂÖÉÁ¥† */
            white-space: normal; /* ÂÖÅËÆ∏Ëá™Âä®Êç¢Ë°å */
        }
        .quiz-choice:hover {
            background-color: #f0f0f0;
        }
        .quiz-choice.selected {
            background-color: #d3e3fd;
            border-color: #1a73e8;
        }
        .quiz-choice.correct {
            background-color: #d4f8d9;
            border-color: #0f9d58;
        }
        .quiz-choice.incorrect {
            background-color: #ffd7d5;
            border-color: #d93025;
        }
        .quiz-feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            display: none;
            font-weight: bold;
            text-align: center;
        }
        .quiz-feedback.correct {
            background-color: #d4f8d9;
            color: #0f9d58;
            display: block;
            border: 1px solid #0f9d58;
        }
        .quiz-feedback.incorrect {
            background-color: #ffd7d5;
            color: #d93025;
            display: block;
            border: 1px solid #d93025;
        }
        
        /* ÈïøÊñáÊú¨ÈÄâÈ°πÁöÑÁâπÊÆäÊ†∑Âºè */
        .quiz-choice.long-text {
            font-size: 13px;
            line-height: 1.3;
            padding: 10px 12px;
        }
        
        /* Á°Æ‰øùÂºπÁ™ó‰∏≠ÁöÑÊåâÈíÆÊñáÊú¨‰∏ç‰ºöÊ∫¢Âá∫ */
        .quiz-choice button,
        .quiz-choice a {
            word-break: break-word;
            white-space: normal;
            text-align: left;
            width: 100%;
        }
        
        /* ÈÄÇÂ∫îË∂ÖÈïøÈÄâÈ°πÊñáÊú¨ */
        @media (max-width: 500px) {
            .quiz-popup {
                width: 95%;
                padding: 12px;
            }
            .quiz-question {
                font-size: 15px;
                margin-bottom: 12px;
            }
            .quiz-choice {
                padding: 8px 10px;
                font-size: 13px;
                line-height: 1.3;
            }
            .quiz-feedback {
                font-size: 13px;
                padding: 8px;
            }
        }
        
        /* ‰∏≠Á≠âÂ±èÂπïËÆæÂ§áÔºàÂ¶ÇÂπ≥ÊùøÔºâ */
        @media (max-width: 1024px) {
            .card-deck {
                min-height: 500px;
            }

            .card-deck .paper-card {
                max-height: 88vh;
            }
        }

        /* ÁßªÂä®ËÆæÂ§áÂíåÂ∞èÂ±èÂπï */
        @media (max-width: 768px) {
            body {
                padding: 10px; /* ÂáèÂ∞ëÁßªÂä®ËÆæÂ§á‰∏äÁöÑÂÜÖËæπË∑ù */
            }

            .paper-container {
                flex-direction: column;
            }

            .card-deck {
                margin-right: 0;
                margin-bottom: 40px;
                min-height: 400px; /* ÁßªÂä®ËÆæÂ§á‰∏ä‰ΩøÁî®Êõ¥Â∞èÁöÑÊúÄÂ∞èÈ´òÂ∫¶ */
                height: auto; /* Ëá™ÈÄÇÂ∫îÈ´òÂ∫¶ */
            }

            .card-deck .paper-card {
                max-height: 85vh; /* ÁßªÂä®ËÆæÂ§á‰∏äÈôêÂà∂Êõ¥Â§ö */
                font-size: 0.95em; /* Á®çÂæÆÂáèÂ∞èÂ≠ó‰Ωì */
            }

            .paper-card h2 {
                font-size: 1.1em; /* ÁßªÂä®ËÆæÂ§á‰∏äË∞ÉÊï¥Ê†áÈ¢òÂ§ßÂ∞è */
            }

            .paper-container > .paper-card {
                width: 100% !important;
                margin-bottom: 20px;
                margin-right: 0;
            }

            .quiz-tabs {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: flex-start;
                position: relative;
                margin-left: 0;
            }

            .quiz-tab {
                margin-right: 10px;
                margin-bottom: 10px;
                width: 45px; /* ÁßªÂä®ËÆæÂ§á‰∏äÁ®çÂ∞èÁöÑÊåâÈíÆ */
                height: 45px;
                font-size: 14px;
            }
        }

        /* ÊûÅÂ∞èÂ±èÂπïÔºàÂ¶ÇÂ∞èÊâãÊú∫Ôºâ */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .card-deck {
                min-height: 300px;
            }

            .card-deck .paper-card {
                max-height: 80vh;
                font-size: 0.9em;
                padding: 10px;
            }

            .paper-card h2 {
                font-size: 1em;
            }

            .category-chunk {
                padding: 8px;
                font-size: 0.9em;
            }

            .quiz-tab {
                width: 40px;
                height: 40px;
                font-size: 12px;
            }
        }

        /* Personal Takeaways Section Styles */
        .takeaways-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 30px;
            margin: 40px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .takeaways-section h2 {
            color: #ffffff;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .takeaways-content {
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 25px;
            line-height: 1.8;
            color: #333;
        }

        .takeaways-content h3 {
            color: #667eea;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .takeaways-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 15px 0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .takeaways-content p {
            margin: 15px 0;
        }

        .takeaways-content ul, .takeaways-content ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        .takeaways-content li {
            margin: 8px 0;
        }

        .takeaways-content blockquote {
            border-left: 4px solid #667eea;
            padding-left: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #555;
            background-color: #f8f9fa;
            padding: 15px 20px;
            border-radius: 4px;
        }

        .takeaways-content code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #d73a49;
        }

        .takeaways-content pre {
            background-color: #f6f8fa;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #e1e4e8;
        }

        .takeaways-content pre code {
            background-color: transparent;
            padding: 0;
            color: #333;
        }
    </style>
</head>
<body>
    <h1>2026-02-25 Papers</h1>
    
            <div class="paper-container">
                <div class="card-deck">
                    <!-- Âç°ÁâáËÆ°Êï∞Âô® -->
                    <div class="card-counter">1/2</div>
                    
                    <!-- Á¨¨‰∏ÄÂº†Âç°ÁâáÔºöËÆ∫ÊñáÊ¶ÇËø∞ -->
                    <div class="paper-card active" style="background-image: url('bg/black-linen-2.png');">
                        <h2 style="color: #ffffff;">Paper 1</h2>
                        <p style="color: #badb12;"><strong>Decoding as Optimisation on the Probability Simplex: From Top-K to Top-P (Nucleus) to Best-of-K Samplers</strong></p>
                        <p style="color: #ffffff;"><strong>Published: </strong>2026-02-20</p>
                        <p><strong>Link: </strong><a href="http://arxiv.org/pdf/2602.18292" target="_blank">http://arxiv.org/pdf/2602.18292</a></p>
                        <div><div class="category-chunk">1.  <strong>üìò Topic and Domain:</strong> Language model decoding strategies viewed as optimization problems on the probability simplex.</div><div class="category-chunk">2.  <strong>üí° Previous Research and New Ideas:</strong> Builds on classical decoding methods (greedy, softmax, top-k, top-p) by proving they are special cases of a unified optimization framework, and introduces Best-of-K (BoK) sampler for multi-sample generation scenarios.</div><div class="category-chunk">3.  <strong>‚ùì Problem:</strong> Current decoding methods are treated as disconnected heuristics rather than principled solutions, and existing methods perform poorly in multi-sample pipelines where coverage of good alternatives matters.</div><div class="category-chunk">4.  <strong>üõ†Ô∏è Methods:</strong> Formulates decoding as regularized optimization over probability distributions, derives KKT conditions for optimality, and uses mirror ascent algorithm for cases without closed-form solutions.</div><div class="category-chunk">5.  <strong>üìä Results and Evaluation:</strong> BoK sampler improves accuracy by up to +18.6% on MATH500 at high temperatures compared to baseline, with consistent gains across three benchmarks (MATH500, GPQA, HumanEval) while adding minimal computational overhead (~1s).</div></div>
                    </div>
                    
                    <!-- Á¨¨‰∫åÂº†Âç°ÁâáÔºöÊµÅÁ®ãÂõæ -->
                    <div class="paper-card flowchart-card" style="background-color: white;">
                        <h2>Decoding as Optimisation on the Probability Simplex: From Top-K to Top-P (Nucleus) to Best-of-K Samplers</h2>
                        <svg width="100%" viewBox="0 0 1000 800">
  <!-- Title -->
  <text x="500" y="30" text-anchor="middle" font-size="24" font-weight="bold" fill="#2C3E50">
    Decoding as Optimisation: Method Flow
  </text>
  
  <!-- Main Framework Box -->
  <rect x="250" y="60" width="500" height="120" fill="#3498DB" stroke="#2C3E50" stroke-width="3" rx="10"/>
  <text x="500" y="100" text-anchor="middle" font-size="18" font-weight="bold" fill="white">
    Master Objective
  </text>
  <text x="500" y="130" text-anchor="middle" font-size="16" fill="white">
    max q‚ààŒî(V) [‚ü®q,st‚ü© - ŒªŒ©(q)]
  </text>
  <text x="500" y="155" text-anchor="middle" font-size="14" fill="white">
    subject to: q ‚àà Ct
  </text>
  
  <!-- Arrows from Master to Special Cases -->
  <line x1="200" y1="180" x2="150" y2="250" stroke="#34495E" stroke-width="2" marker-end="url(#arrowhead)"/>
  <line x1="350" y1="180" x2="300" y2="250" stroke="#34495E" stroke-width="2" marker-end="url(#arrowhead)"/>
  <line x1="500" y1="180" x2="500" y2="250" stroke="#34495E" stroke-width="2" marker-end="url(#arrowhead)"/>
  <line x1="650" y1="180" x2="700" y2="250" stroke="#34495E" stroke-width="2" marker-end="url(#arrowhead)"/>
  <line x1="800" y1="180" x2="850" y2="250" stroke="#34495E" stroke-width="2" marker-end="url(#arrowhead)"/>
  
  <!-- Special Cases -->
  <!-- Greedy -->
  <rect x="50" y="250" width="150" height="100" fill="#E74C3C" stroke="#C0392B" stroke-width="2" rx="8"/>
  <text x="125" y="280" text-anchor="middle" font-size="16" font-weight="bold" fill="white">
    Greedy
  </text>
  <text x="125" y="305" text-anchor="middle" font-size="12" fill="white">
    Œª = 0
  </text>
  <text x="125" y="325" text-anchor="middle" font-size="11" fill="white">
    (closed form)
  </text>
  
  <!-- Softmax -->
  <rect x="225" y="250" width="150" height="100" fill="#9B59B6" stroke="#8E44AD" stroke-width="2" rx="8"/>
  <text x="300" y="280" text-anchor="middle" font-size="16" font-weight="bold" fill="white">
    Softmax
  </text>
  <text x="300" y="305" text-anchor="middle" font-size="12" fill="white">
    Œ© = -H(q)
  </text>
  <text x="300" y="325" text-anchor="middle" font-size="11" fill="white">
    (closed form)
  </text>
  
  <!-- Top-K/P -->
  <rect x="425" y="250" width="150" height="100" fill="#1ABC9C" stroke="#16A085" stroke-width="2" rx="8"/>
  <text x="500" y="280" text-anchor="middle" font-size="16" font-weight="bold" fill="white">
    Top-K/P
  </text>
  <text x="500" y="305" text-anchor="middle" font-size="12" fill="white">
    Support Ct
  </text>
  <text x="500" y="325" text-anchor="middle" font-size="11" fill="white">
    (closed form)
  </text>
  
  <!-- Sparsemax -->
  <rect x="625" y="250" width="150" height="100" fill="#F39C12" stroke="#E67E22" stroke-width="2" rx="8"/>
  <text x="700" y="280" text-anchor="middle" font-size="16" font-weight="bold" fill="white">
    Sparsemax
  </text>
  <text x="700" y="305" text-anchor="middle" font-size="12" fill="white">
    Œ© ‚àù ||q||¬≤‚ÇÇ
  </text>
  <text x="700" y="325" text-anchor="middle" font-size="11" fill="white">
    (closed form)
  </text>
  
  <!-- BoK -->
  <rect x="800" y="250" width="150" height="100" fill="#27AE60" stroke="#229954" stroke-width="2" rx="8"/>
  <text x="875" y="280" text-anchor="middle" font-size="16" font-weight="bold" fill="white">
    BoK
  </text>
  <text x="875" y="305" text-anchor="middle" font-size="12" fill="white">
    Œ©(BoK)
  </text>
  <text x="875" y="325" text-anchor="middle" font-size="11" fill="white">
    (mirror ascent)
  </text>
  
  <!-- KKT Conditions Box -->
  <rect x="250" y="400" width="500" height="140" fill="#34495E" stroke="#2C3E50" stroke-width="3" rx="10"/>
  <text x="500" y="430" text-anchor="middle" font-size="18" font-weight="bold" fill="white">
    KKT Optimality Conditions
  </text>
  <text x="500" y="460" text-anchor="middle" font-size="14" fill="white">
    GLOBAL: Œ£q*(v) = 1, q*(v) ‚â• 0
  </text>
  <text x="500" y="485" text-anchor="middle" font-size="14" fill="white">
    ACTIVE: q*(v) > 0 ‚üπ st(v) - Œª‚àáŒ©(q*)(v) = Œ∑
  </text>
  <text x="500" y="510" text-anchor="middle" font-size="14" fill="white">
    INACTIVE: q*(v) = 0 ‚üπ st(v) - Œª‚àáŒ©(q*)(v) ‚â§ Œ∑
  </text>
  
  <!-- Mirror Ascent Box -->
  <rect x="250" y="580" width="500" height="100" fill="#E67E22" stroke="#D35400" stroke-width="3" rx="10"/>
  <text x="500" y="610" text-anchor="middle" font-size="18" font-weight="bold" fill="white">
    Mirror Ascent Algorithm
  </text>
  <text x="500" y="640" text-anchor="middle" font-size="14" fill="white">
    q‚±º‚Çä‚ÇÅ = q‚±º ‚äô exp(Œ∑g‚±º) / ||q‚±º ‚äô exp(Œ∑g‚±º)||‚ÇÅ
  </text>
  <text x="500" y="660" text-anchor="middle" font-size="12" fill="white">
    (For non-closed-form objectives like BoK)
  </text>
  
  <!-- Connecting lines -->
  <line x1="500" y1="350" x2="500" y2="400" stroke="#34495E" stroke-width="2" stroke-dasharray="5,5"/>
  <line x1="500" y1="540" x2="500" y2="580" stroke="#34495E" stroke-width="2" stroke-dasharray="5,5"/>
  <line x1="875" y1="350" x2="750" y2="580" stroke="#27AE60" stroke-width="2" stroke-dasharray="5,5"/>
  
  <!-- Arrow marker definition -->
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#34495E"/>
    </marker>
  </defs>
  
  <!-- Background gradient -->
  <defs>
    <linearGradient id="bgGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#ECF0F1;stop-opacity:0.3"/>
      <stop offset="100%" style="stop-color:#BDC3C7;stop-opacity:0.3"/>
    </linearGradient>
  </defs>
  <rect x="0" y="0" width="1000" height="800" fill="url(#bgGradient)" opacity="0.5"/>
</svg>
                    </div>
                </div>
                <div class="quiz-tabs">
                <div class="quiz-tab" title="Click To Open Question #1">Q1
                    <div class="quiz-popup" data-answer="They are solutions to the same optimization problem with different regularizers on the probability simplex">
                        <div class="quiz-question">1. What mathematical insight allows the paper to unify different decoding strategies like greedy, softmax, and top-k sampling?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="They all minimize the same loss function with different learning rates">They all minimize the same loss function with different learning rates</div><div class="quiz-choice long-text" data-value="They are solutions to the same optimization problem with different regularizers on the probability simplex">They are solutions to the same optimization problem with different regularizers on the probability simplex</div><div class="quiz-choice" data-value="They use the same neural network architecture but with different activation functions">They use the same neural network architecture but with different activation functions</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #2">Q2
                    <div class="quiz-popup" data-answer="It implicitly assumes Euclidean geometry which is a poor match for the simplex manifold">
                        <div class="quiz-question">2. Why does the paper argue that projected gradient ascent is suboptimal for optimizing over probability distributions?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="It requires too much memory to store gradients for large vocabularies">It requires too much memory to store gradients for large vocabularies</div><div class="quiz-choice" data-value="It converges too slowly compared to other optimization methods">It converges too slowly compared to other optimization methods</div><div class="quiz-choice" data-value="It implicitly assumes Euclidean geometry which is a poor match for the simplex manifold">It implicitly assumes Euclidean geometry which is a poor match for the simplex manifold</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #3">Q3
                    <div class="quiz-popup" data-answer="It optimizes for coverage by maximizing the probability that good tokens appear at least once in K samples">
                        <div class="quiz-question">3. What is the key innovation of the Best-of-K (BoK) sampler that makes it effective for multi-sample generation?</div>
                        <div class="quiz-choices"><div class="quiz-choice long-text" data-value="It optimizes for coverage by maximizing the probability that good tokens appear at least once in K samples">It optimizes for coverage by maximizing the probability that good tokens appear at least once in K samples</div><div class="quiz-choice" data-value="It uses a transformer architecture to predict which K tokens to sample">It uses a transformer architecture to predict which K tokens to sample</div><div class="quiz-choice" data-value="It pre-computes the top K tokens offline to reduce sampling latency">It pre-computes the top K tokens offline to reduce sampling latency</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                </div>
            </div>
            
            <div class="paper-container">
                <div class="card-deck">
                    <!-- Âç°ÁâáËÆ°Êï∞Âô® -->
                    <div class="card-counter">1/2</div>
                    
                    <!-- Á¨¨‰∏ÄÂº†Âç°ÁâáÔºöËÆ∫ÊñáÊ¶ÇËø∞ -->
                    <div class="paper-card active" style="background-image: url('bg/argyle.png');">
                        <h2 style="color: #ffffff;">Paper 2</h2>
                        <p style="color: #badb12;"><strong>tttLRM: Test-Time Training for Long Context and Autoregressive 3D Reconstruction</strong></p>
                        <p style="color: #ffffff;"><strong>Published: </strong>2026-02-23</p>
                        <p><strong>Link: </strong><a href="http://arxiv.org/pdf/2602.20160" target="_blank">http://arxiv.org/pdf/2602.20160</a></p>
                        <div><div class="category-chunk">1.  <strong>üìò Topic and Domain:</strong> The paper presents tttLRM, a Large Reconstruction Model that leverages Test-Time Training (TTT) for high-resolution, long-context, and autoregressive 3D reconstruction from multiple images.</div><div class="category-chunk">2.  <strong>üí° Previous Research and New Ideas:</strong> The paper builds on Large Reconstruction Models (LRMs) and Test-Time Training approaches, proposing a novel architecture that interprets TTT fast weights as implicit 3D representations that can be decoded into explicit formats like 3D Gaussian Splatting with linear computational complexity.</div><div class="category-chunk">3.  <strong>‚ùì Problem:</strong> The paper aims to solve the limitation of existing 3D reconstruction methods that either require slow per-scene optimization or are restricted to processing only a few input views due to quadratic attention complexity.</div><div class="category-chunk">4.  <strong>üõ†Ô∏è Methods:</strong> The authors use LaCT (Large Chunk Test-Time Training) blocks with linear complexity, encode input images as tokens that update fast weights during inference, and query these weights with virtual tokens to decode into explicit 3D representations like Gaussian Splats.</div><div class="category-chunk">5.  <strong>üìä Results and Evaluation:</strong> The method achieves state-of-the-art performance on object (GSO) and scene-level (DL3DV-140, Tanks&Temples) datasets, outperforming GS-LRM and Long-LRM in PSNR/SSIM/LPIPS metrics while supporting up to 64 input views and being hundreds of times faster than optimization-based methods.</div></div>
                    </div>
                    
                    <!-- Á¨¨‰∫åÂº†Âç°ÁâáÔºöÊµÅÁ®ãÂõæ -->
                    <div class="paper-card flowchart-card" style="background-color: white;">
                        <h2>tttLRM: Test-Time Training for Long Context and Autoregressive 3D Reconstruction</h2>
                        <svg width="100%" viewBox="0 0 1000 800">
  <!-- Title -->
  <text x="500" y="30" font-size="24" font-weight="bold" text-anchor="middle" fill="#2C3E50">tttLRM: Test-Time Training Workflow</text>
  
  <!-- Input Stage -->
  <rect x="50" y="60" width="180" height="80" rx="10" fill="#3498DB" stroke="#2980B9" stroke-width="2"/>
  <text x="140" y="90" font-size="14" font-weight="bold" text-anchor="middle" fill="white">Input Views</text>
  <text x="140" y="110" font-size="12" text-anchor="middle" fill="white">{I‚ÇÅ, I‚ÇÇ, ..., I‚Çô}</text>
  <text x="140" y="125" font-size="10" text-anchor="middle" fill="white">+ Ray Embeddings</text>
  
  <!-- Patchify & Tokenize -->
  <rect x="280" y="60" width="160" height="80" rx="10" fill="#9B59B6" stroke="#8E44AD" stroke-width="2"/>
  <text x="360" y="85" font-size="14" font-weight="bold" text-anchor="middle" fill="white">Patchify &amp;</text>
  <text x="360" y="105" font-size="14" font-weight="bold" text-anchor="middle" fill="white">Tokenize</text>
  <text x="360" y="125" font-size="10" text-anchor="middle" fill="white">Linear Layer</text>
  
  <!-- LaCT Blocks -->
  <rect x="490" y="60" width="200" height="180" rx="15" fill="#E74C3C" stroke="#C0392B" stroke-width="3"/>
  <text x="590" y="85" font-size="16" font-weight="bold" text-anchor="middle" fill="white">LaCT Blocks (√óL)</text>
  
  <!-- Window Attention -->
  <rect x="510" y="105" width="160" height="40" rx="5" fill="#EC7063" stroke="#CB4335" stroke-width="1"/>
  <text x="590" y="130" font-size="12" text-anchor="middle" fill="white">Window Attention</text>
  
  <!-- Fast Weights Update -->
  <rect x="510" y="155" width="160" height="40" rx="5" fill="#EC7063" stroke="#CB4335" stroke-width="1"/>
  <text x="590" y="175" font-size="12" text-anchor="middle" fill="white">Fast Weights Update</text>
  <text x="590" y="190" font-size="10" text-anchor="middle" fill="white">W = Update({T·µ¢})</text>
  
  <!-- Apply Operation -->
  <rect x="510" y="200" width="160" height="30" rx="5" fill="#EC7063" stroke="#CB4335" stroke-width="1"/>
  <text x="590" y="220" font-size="12" text-anchor="middle" fill="white">Apply(W, T·µ¢)</text>
  
  <!-- Virtual Views Query -->
  <rect x="740" y="60" width="180" height="80" rx="10" fill="#16A085" stroke="#138D75" stroke-width="2"/>
  <text x="830" y="85" font-size="14" font-weight="bold" text-anchor="middle" fill="white">Virtual Views</text>
  <text x="830" y="105" font-size="14" font-weight="bold" text-anchor="middle" fill="white">Query</text>
  <text x="830" y="125" font-size="10" text-anchor="middle" fill="white">{I^v‚ÇÅ, I^v‚ÇÇ, ..., I^v‚Çò}</text>
  
  <!-- 3D Representation Decode -->
  <rect x="280" y="290" width="200" height="100" rx="10" fill="#F39C12" stroke="#E67E22" stroke-width="2"/>
  <text x="380" y="320" font-size="16" font-weight="bold" text-anchor="middle" fill="white">3D Decode</text>
  <text x="380" y="345" font-size="12" text-anchor="middle" fill="white">‚Ä¢ 3D Gaussians</text>
  <text x="380" y="365" font-size="12" text-anchor="middle" fill="white">‚Ä¢ Triplane NeRF</text>
  
  <!-- Novel View Synthesis -->
  <rect x="530" y="290" width="180" height="100" rx="10" fill="#27AE60" stroke="#229954" stroke-width="2"/>
  <text x="620" y="315" font-size="16" font-weight="bold" text-anchor="middle" fill="white">Novel View</text>
  <text x="620" y="335" font-size="16" font-weight="bold" text-anchor="middle" fill="white">Synthesis</text>
  <text x="620" y="360" font-size="12" text-anchor="middle" fill="white">Real-time Rendering</text>
  
  <!-- Autoregressive Path -->
  <rect x="50" y="440" width="300" height="120" rx="15" fill="#34495E" stroke="#2C3E50" stroke-width="2" stroke-dasharray="5,5"/>
  <text x="200" y="465" font-size="16" font-weight="bold" text-anchor="middle" fill="white">Autoregressive Mode</text>
  <text x="200" y="490" font-size="12" text-anchor="middle" fill="white">For streaming inputs:</text>
  <text x="200" y="510" font-size="11" text-anchor="middle" fill="white">1. Update W with new batch</text>
  <text x="200" y="530" font-size="11" text-anchor="middle" fill="white">2. Predict G(b) immediately</text>
  <text x="200" y="550" font-size="11" text-anchor="middle" fill="white">3. Maintain historical gradients</text>
  
  <!-- Distributed Training -->
  <rect x="400" y="440" width="300" height="120" rx="15" fill="#7F8C8D" stroke="#95A5A6" stroke-width="2" stroke-dasharray="5,5"/>
  <text x="550" y="465" font-size="16" font-weight="bold" text-anchor="middle" fill="white">Distributed Training</text>
  <text x="550" y="490" font-size="12" text-anchor="middle" fill="white">Sequence Parallelism:</text>
  <text x="550" y="510" font-size="11" text-anchor="middle" fill="white">‚Ä¢ Shard tokens across GPUs</text>
  <text x="550" y="530" font-size="11" text-anchor="middle" fill="white">‚Ä¢ Synchronize fast weights</text>
  <text x="550" y="550" font-size="11" text-anchor="middle" fill="white">‚Ä¢ All-reduce gradients</text>
  
  <!-- Training Loss -->
  <rect x="750" y="440" width="200" height="120" rx="15" fill="#C0392B" stroke="#A93226" stroke-width="2"/>
  <text x="850" y="465" font-size="16" font-weight="bold" text-anchor="middle" fill="white">Training Loss</text>
  <text x="850" y="490" font-size="12" text-anchor="middle" fill="white">L = L_RGB +</text>
  <text x="850" y="510" font-size="12" text-anchor="middle" fill="white">Œª_depth √ó L_depth +</text>
  <text x="850" y="530" font-size="12" text-anchor="middle" fill="white">Œª_opacity √ó L_opacity</text>
  
  <!-- Arrows -->
  <path d="M 230 100 L 280 100" stroke="#34495E" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  <path d="M 440 100 L 490 100" stroke="#34495E" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  <path d="M 690 150 L 740 150" stroke="#34495E" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  <path d="M 830 140 L 830 180 L 690 180" stroke="#34495E" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  <path d="M 590 240 L 590 270 L 480 270 L 480 290" stroke="#34495E" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  <path d="M 480 340 L 530 340" stroke="#34495E" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  <path d="M 620 390 L 620 420 L 850 420 L 850 440" stroke="#34495E" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  <path d="M 200 240 L 200 440" stroke="#34495E" stroke-width="2" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5"/>
  
  <!-- Arrow marker definition -->
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#34495E"/>
    </marker>
  </defs>
  
  <!-- Key Features -->
  <rect x="50" y="600" width="900" height="180" rx="20" fill="#ECF0F1" stroke="#BDC3C7" stroke-width="2"/>
  <text x="500" y="630" font-size="18" font-weight="bold" text-anchor="middle" fill="#2C3E50">Key Features</text>
  
  <circle cx="100" cy="660" r="5" fill="#E74C3C"/>
  <text x="120" y="665" font-size="14" fill="#2C3E50">Linear Complexity O(N) vs Traditional O(N¬≤)</text>
  
  <circle cx="100" cy="690" r="5" fill="#3498DB"/>
  <text x="120" y="695" font-size="14" fill="#2C3E50">Supports up to 64+ input views (1M+ tokens)</text>
  
  <circle cx="100" cy="720" r="5" fill="#27AE60"/>
  <text x="120" y="725" font-size="14" fill="#2C3E50">Flexible output: 3D Gaussians, Triplane NeRF</text>
  
  <circle cx="500" cy="660" r="5" fill="#9B59B6"/>
  <text x="520" y="665" font-size="14" fill="#2C3E50">Fast feedforward reconstruction (~15s for 64 views)</text>
  
  <circle cx="500" cy="690" r="5" fill="#F39C12"/>
  <text x="520" y="695" font-size="14" fill="#2C3E50">Autoregressive streaming capability</text>
  
  <circle cx="500" cy="720" r="5" fill="#16A085"/>
  <text x="520" y="725" font-size="14" fill="#2C3E50">Pretrained on novel view synthesis tasks</text>
</svg>
                    </div>
                </div>
                <div class="quiz-tabs">
                <div class="quiz-tab" title="Click To Open Question #1">Q1
                    <div class="quiz-popup" data-answer="Using LaCT (Large Chunk Test-Time Training) blocks that update fast weights as implicit 3D memory">
                        <div class="quiz-question">1. What is the key architectural innovation that allows tttLRM to process long sequences of input views with linear computational complexity?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="Using LaCT (Large Chunk Test-Time Training) blocks that update fast weights as implicit 3D memory">Using LaCT (Large Chunk Test-Time Training) blocks that update fast weights as implicit 3D memory</div><div class="quiz-choice" data-value="Implementing multi-head self-attention with kernel approximations">Implementing multi-head self-attention with kernel approximations</div><div class="quiz-choice" data-value="Applying hierarchical pooling to reduce sequence length progressively">Applying hierarchical pooling to reduce sequence length progressively</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #2">Q2
                    <div class="quiz-popup" data-answer="It incrementally updates fast weights like an RNN, immediately predicting 3D Gaussians for new views">
                        <div class="quiz-question">2. How does tttLRM's autoregressive reconstruction capability work when processing streaming visual inputs?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="It stores all previous views in a buffer and reprocesses them with each new input">It stores all previous views in a buffer and reprocesses them with each new input</div><div class="quiz-choice" data-value="It incrementally updates fast weights like an RNN, immediately predicting 3D Gaussians for new views">It incrementally updates fast weights like an RNN, immediately predicting 3D Gaussians for new views</div><div class="quiz-choice" data-value="It waits until all views are collected before beginning the reconstruction process">It waits until all views are collected before beginning the reconstruction process</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #3">Q3
                    <div class="quiz-popup" data-answer="It significantly accelerated convergence and improved final reconstruction quality even for different 3D representations">
                        <div class="quiz-question">3. What unexpected benefit did the authors discover when pretraining tttLRM with novel view synthesis tasks before fine-tuning for 3D reconstruction?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="It reduced the model size by 50% through weight pruning">It reduced the model size by 50% through weight pruning</div><div class="quiz-choice" data-value="It enabled the model to work without camera pose information">It enabled the model to work without camera pose information</div><div class="quiz-choice long-text" data-value="It significantly accelerated convergence and improved final reconstruction quality even for different 3D representations">It significantly accelerated convergence and improved final reconstruction quality even for different 3D representations</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                </div>
            </div>
            
            <div class="paper-container">
                <div class="card-deck">
                    <!-- Âç°ÁâáËÆ°Êï∞Âô® -->
                    <div class="card-counter">1/2</div>
                    
                    <!-- Á¨¨‰∏ÄÂº†Âç°ÁâáÔºöËÆ∫ÊñáÊ¶ÇËø∞ -->
                    <div class="paper-card active" style="background-image: url('bg/black-orchid.png');">
                        <h2 style="color: #ffffff;">Paper 3</h2>
                        <p style="color: #badb12;"><strong>SpargeAttention2: Trainable Sparse Attention via Hybrid Top-k+Top-p Masking and Distillation Fine-Tuning</strong></p>
                        <p style="color: #ffffff;"><strong>Published: </strong>2026-02-13</p>
                        <p><strong>Link: </strong><a href="http://arxiv.org/pdf/2602.13515" target="_blank">http://arxiv.org/pdf/2602.13515</a></p>
                        <div><div class="category-chunk">1.  <strong>üìò Topic and Domain:</strong> The paper focuses on trainable sparse attention methods for accelerating video diffusion models in computer vision.</div><div class="category-chunk">2.  <strong>üí° Previous Research and New Ideas:</strong> The paper builds on existing sparse attention methods like SpargeAttention and VSA, proposing a hybrid Top-k+Top-p masking strategy combined with velocity distillation for fine-tuning.</div><div class="category-chunk">3.  <strong>‚ùì Problem:</strong> The paper aims to achieve high attention sparsity (>90%) in video diffusion models without degrading generation quality, addressing failures of existing masking rules and fine-tuning approaches.</div><div class="category-chunk">4.  <strong>üõ†Ô∏è Methods:</strong> The authors use a hybrid Top-k+Top-p masking rule, implement an efficient CUDA-based sparse attention kernel, and employ velocity distillation loss instead of standard diffusion loss for fine-tuning.</div><div class="category-chunk">5.  <strong>üìä Results and Evaluation:</strong> SpargeAttention2 achieves 95% attention sparsity with 16.2√ó attention speedup and up to 4.7√ó end-to-end generation speedup while maintaining video quality comparable to full attention, evaluated on Wan2.1 models using VBench metrics.</div></div>
                    </div>
                    
                    <!-- Á¨¨‰∫åÂº†Âç°ÁâáÔºöÊµÅÁ®ãÂõæ -->
                    <div class="paper-card flowchart-card" style="background-color: white;">
                        <h2>SpargeAttention2: Trainable Sparse Attention via Hybrid Top-k+Top-p Masking and Distillation Fine-Tuning</h2>
                        <svg width="100%" viewBox="0 0 1000 800">
  <!-- Title -->
  <text x="500" y="30" font-size="24" font-weight="bold" text-anchor="middle" fill="#1a237e">SpargeAttention2: Method Workflow</text>
  
  <!-- Background gradient -->
  <defs>
    <linearGradient id="bgGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#e3f2fd;stop-opacity:0.3" />
      <stop offset="100%" style="stop-color:#bbdefb;stop-opacity:0.3" />
    </linearGradient>
    <linearGradient id="boxGradient1" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#4fc3f7;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#29b6f6;stop-opacity:1" />
    </linearGradient>
    <linearGradient id="boxGradient2" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#66bb6a;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#4caf50;stop-opacity:1" />
    </linearGradient>
    <linearGradient id="boxGradient3" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#ff7043;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#ff5722;stop-opacity:1" />
    </linearGradient>
  </defs>
  
  <rect x="0" y="0" width="1000" height="800" fill="url(#bgGradient)" />
  
  <!-- Step 1: Analysis -->
  <g transform="translate(100, 70)">
    <rect x="0" y="0" width="800" height="120" rx="10" fill="#e1f5fe" stroke="#0277bd" stroke-width="2"/>
    <text x="400" y="25" font-size="18" font-weight="bold" text-anchor="middle" fill="#01579b">1. Analysis Phase</text>
    
    <rect x="20" y="40" width="240" height="60" rx="5" fill="url(#boxGradient1)"/>
    <text x="140" y="65" font-size="14" text-anchor="middle" fill="white">Case 1: Top-k/Top-p</text>
    <text x="140" y="85" font-size="14" text-anchor="middle" fill="white">Failure Analysis</text>
    
    <rect x="280" y="40" width="240" height="60" rx="5" fill="url(#boxGradient1)"/>
    <text x="400" y="65" font-size="14" text-anchor="middle" fill="white">Case 2: Why Trainable</text>
    <text x="400" y="85" font-size="14" text-anchor="middle" fill="white">Sparse Works Better</text>
    
    <rect x="540" y="40" width="240" height="60" rx="5" fill="url(#boxGradient1)"/>
    <text x="660" y="65" font-size="14" text-anchor="middle" fill="white">Case 3: Diffusion Loss</text>
    <text x="660" y="85" font-size="14" text-anchor="middle" fill="white">Limitations</text>
  </g>
  
  <!-- Step 2: Method Components -->
  <g transform="translate(100, 220)">
    <rect x="0" y="0" width="800" height="180" rx="10" fill="#f3e5f5" stroke="#7b1fa2" stroke-width="2"/>
    <text x="400" y="25" font-size="18" font-weight="bold" text-anchor="middle" fill="#4a148c">2. SpargeAttention2 Components</text>
    
    <!-- Component 1 -->
    <rect x="20" y="50" width="240" height="110" rx="5" fill="url(#boxGradient2)"/>
    <text x="140" y="75" font-size="14" font-weight="bold" text-anchor="middle" fill="white">Hybrid Masking</text>
    <text x="140" y="95" font-size="12" text-anchor="middle" fill="white">Top-k + Top-p</text>
    <text x="140" y="115" font-size="12" text-anchor="middle" fill="white">Handles uniform &amp;</text>
    <text x="140" y="135" font-size="12" text-anchor="middle" fill="white">skewed distributions</text>
    
    <!-- Component 2 -->
    <rect x="280" y="50" width="240" height="110" rx="5" fill="url(#boxGradient2)"/>
    <text x="400" y="75" font-size="14" font-weight="bold" text-anchor="middle" fill="white">Efficient Kernel</text>
    <text x="400" y="95" font-size="12" text-anchor="middle" fill="white">Block-sparse attention</text>
    <text x="400" y="115" font-size="12" text-anchor="middle" fill="white">CUDA implementation</text>
    <text x="400" y="135" font-size="12" text-anchor="middle" fill="white">Based on FlashAttention</text>
    
    <!-- Component 3 -->
    <rect x="540" y="50" width="240" height="110" rx="5" fill="url(#boxGradient2)"/>
    <text x="660" y="75" font-size="14" font-weight="bold" text-anchor="middle" fill="white">Velocity Distillation</text>
    <text x="660" y="95" font-size="12" text-anchor="middle" fill="white">Teacher-student setup</text>
    <text x="660" y="115" font-size="12" text-anchor="middle" fill="white">Preserves generation</text>
    <text x="660" y="135" font-size="12" text-anchor="middle" fill="white">quality</text>
  </g>
  
  <!-- Step 3: Training Process -->
  <g transform="translate(100, 430)">
    <rect x="0" y="0" width="800" height="140" rx="10" fill="#fff3e0" stroke="#e65100" stroke-width="2"/>
    <text x="400" y="25" font-size="18" font-weight="bold" text-anchor="middle" fill="#bf360c">3. Training Process</text>
    
    <!-- Process flow -->
    <rect x="20" y="40" width="180" height="80" rx="5" fill="url(#boxGradient3)"/>
    <text x="110" y="65" font-size="14" text-anchor="middle" fill="white">Pre-trained Model</text>
    <text x="110" y="85" font-size="12" text-anchor="middle" fill="white">(Full Attention)</text>
    <text x="110" y="105" font-size="12" text-anchor="middle" fill="white">Œ∏_full (frozen)</text>
    
    <rect x="230" y="40" width="180" height="80" rx="5" fill="url(#boxGradient3)"/>
    <text x="320" y="65" font-size="14" text-anchor="middle" fill="white">Replace Attention</text>
    <text x="320" y="85" font-size="12" text-anchor="middle" fill="white">with SpargeAttn2</text>
    <text x="320" y="105" font-size="12" text-anchor="middle" fill="white">Œ∏_sparse</text>
    
    <rect x="440" y="40" width="180" height="80" rx="5" fill="url(#boxGradient3)"/>
    <text x="530" y="65" font-size="14" text-anchor="middle" fill="white">Velocity Distillation</text>
    <text x="530" y="85" font-size="12" text-anchor="middle" fill="white">min ||u_sparse -</text>
    <text x="530" y="105" font-size="12" text-anchor="middle" fill="white">u_full||¬≤</text>
    
    <rect x="650" y="40" width="130" height="80" rx="5" fill="#9c27b0"/>
    <text x="715" y="65" font-size="14" text-anchor="middle" fill="white">Optimized</text>
    <text x="715" y="85" font-size="14" text-anchor="middle" fill="white">Sparse Model</text>
    <text x="715" y="105" font-size="12" text-anchor="middle" fill="white">95% sparsity</text>
  </g>
  
  <!-- Results -->
  <g transform="translate(100, 590)">
    <rect x="0" y="0" width="800" height="100" rx="10" fill="#e8f5e9" stroke="#1b5e20" stroke-width="2"/>
    <text x="400" y="25" font-size="18" font-weight="bold" text-anchor="middle" fill="#1b5e20">4. Results</text>
    
    <circle cx="150" cy="60" r="25" fill="#4caf50"/>
    <text x="150" y="65" font-size="14" font-weight="bold" text-anchor="middle" fill="white">95%</text>
    <text x="150" y="95" font-size="12" text-anchor="middle" fill="#2e7d32">Sparsity</text>
    
    <circle cx="300" cy="60" r="25" fill="#ff9800"/>
    <text x="300" y="65" font-size="14" font-weight="bold" text-anchor="middle" fill="white">16.2√ó</text>
    <text x="300" y="95" font-size="12" text-anchor="middle" fill="#e65100">Attn Speedup</text>
    
    <circle cx="450" cy="60" r="25" fill="#2196f3"/>
    <text x="450" y="65" font-size="14" font-weight="bold" text-anchor="middle" fill="white">4.7√ó</text>
    <text x="450" y="95" font-size="12" text-anchor="middle" fill="#0d47a1">E2E Speedup</text>
    
    <circle cx="600" cy="60" r="25" fill="#9c27b0"/>
    <text x="600" y="65" font-size="14" font-weight="bold" text-anchor="middle" fill="white">‚úì</text>
    <text x="600" y="95" font-size="12" text-anchor="middle" fill="#4a148c">Quality Preserved</text>
  </g>
  
  <!-- Flow arrows -->
  <path d="M 500 190 L 500 220" stroke="#424242" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  <path d="M 500 400 L 500 430" stroke="#424242" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  <path d="M 500 570 L 500 590" stroke="#424242" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
  
  <!-- Arrow marker -->
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
      <polygon points="0 0, 10 3, 0 6" fill="#424242"/>
    </marker>
  </defs>
</svg>
                    </div>
                </div>
                <div class="quiz-tabs">
                <div class="quiz-tab" title="Click To Open Question #1">Q1
                    <div class="quiz-popup" data-answer="Fine-tuning makes attention distributions more concentrated, reducing both dropped error and renormalization error">
                        <div class="quiz-question">1. What is the key insight behind why trainable sparse attention can achieve higher sparsity than training-free methods?</div>
                        <div class="quiz-choices"><div class="quiz-choice long-text" data-value="Trainable methods use more sophisticated masking algorithms that can identify important tokens better">Trainable methods use more sophisticated masking algorithms that can identify important tokens better</div><div class="quiz-choice long-text" data-value="Fine-tuning makes attention distributions more concentrated, reducing both dropped error and renormalization error">Fine-tuning makes attention distributions more concentrated, reducing both dropped error and renormalization error</div><div class="quiz-choice" data-value="Trainable methods have access to larger computational resources during inference">Trainable methods have access to larger computational resources during inference</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #2">Q2
                    <div class="quiz-popup" data-answer="Standard diffusion loss causes performance degradation when fine-tuning data distribution differs from pre-training data">
                        <div class="quiz-question">2. Why does SpargeAttention2 use velocity distillation loss instead of standard diffusion loss for fine-tuning?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="Velocity distillation is computationally faster and requires less memory">Velocity distillation is computationally faster and requires less memory</div><div class="quiz-choice long-text" data-value="Standard diffusion loss causes performance degradation when fine-tuning data distribution differs from pre-training data">Standard diffusion loss causes performance degradation when fine-tuning data distribution differs from pre-training data</div><div class="quiz-choice" data-value="Velocity distillation allows for higher sparsity ratios in the attention mechanism">Velocity distillation allows for higher sparsity ratios in the attention mechanism</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                
                <div class="quiz-tab" title="Click To Open Question #3">Q3
                    <div class="quiz-popup" data-answer="When dealing with both uniform probability distributions (where Top-p excels) and skewed distributions (where Top-k excels)">
                        <div class="quiz-question">3. When does the hybrid Top-k+Top-p masking strategy outperform individual masking methods?</div>
                        <div class="quiz-choices"><div class="quiz-choice" data-value="Only when attention sparsity is below 50%">Only when attention sparsity is below 50%</div><div class="quiz-choice long-text" data-value="When dealing with both uniform probability distributions (where Top-p excels) and skewed distributions (where Top-k excels)">When dealing with both uniform probability distributions (where Top-p excels) and skewed distributions (where Top-k excels)</div><div class="quiz-choice" data-value="Exclusively during the training phase but not during inference">Exclusively during the training phase but not during inference</div></div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
                </div>
            </div>
            

    <!-- Personal Takeaways Section -->
    <div id="takeaways-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- MathJax for LaTeX rendering (only for takeaways section) -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            },
            startup: {
                pageReady: () => {
                    // Disable automatic processing - we'll only process takeaways manually
                    return Promise.resolve();
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Load and render markdown takeaways
            const dateMatch = document.querySelector('h1').textContent.match(/(\d{4}-\d{2}-\d{2})/);
            if (dateMatch) {
                const date = dateMatch[1];
                const mdPath = `../notes/${date}.md`;

                // Use XMLHttpRequest for better file:// protocol support
                const xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        console.log('XHR Status:', xhr.status, 'Response length:', xhr.responseText.length);

                        if (xhr.status === 200 || xhr.status === 0) {  // status 0 for file://
                            const markdown = xhr.responseText;

                            if (!markdown || markdown.trim().length === 0) {
                                console.log('Empty markdown file');
                                return;
                            }

                            console.log('Markdown loaded, length:', markdown.length);

                            // Check if marked is loaded
                            if (typeof marked === 'undefined') {
                                console.error('marked.js library not loaded');
                                return;
                            }

                            // Convert markdown to HTML
                            const htmlContent = marked.parse(markdown);
                            console.log('HTML converted, length:', htmlContent.length);

                            // Fix image paths
                            const fixedContent = htmlContent.replace(
                                /src="(?!http:\/\/|https:\/\/|\/|\.\.\/)([^"]+)"/g,
                                `src="../images/${date}/$1"`
                            );

                            // Wrap in styled divs
                            const wrappedHtml = `
                                <div class="takeaways-section">
                                    <h2>üìù My Takeaways</h2>
                                    <div class="takeaways-content">
                                        ${fixedContent}
                                    </div>
                                </div>
                            `;

                            document.getElementById('takeaways-container').innerHTML = wrappedHtml;
                            console.log('Takeaways section rendered');

                            // Trigger MathJax to render LaTeX equations
                            if (typeof MathJax !== 'undefined') {
                                MathJax.typesetPromise([document.getElementById('takeaways-container')])
                                    .then(() => {
                                        console.log('MathJax rendering complete');
                                    })
                                    .catch((err) => console.error('MathJax rendering error:', err));
                            }
                        } else {
                            console.log('XHR failed - Status:', xhr.status);
                        }
                    }
                };
                xhr.open('GET', mdPath, true);
                console.log('Loading markdown from:', mdPath);
                xhr.send();
            }

            // ÂàõÂª∫ÈÅÆÁΩ©Â±Ç
            const backdrop = document.createElement('div');
            backdrop.className = 'popup-backdrop';
            document.body.appendChild(backdrop);
            
            // Ëé∑ÂèñÊâÄÊúâÈóÆÈ¢òÊ†áÁ≠æ
            const quizTabs = document.querySelectorAll('.quiz-tab');
            
            // ËÆæÁΩÆÁÇπÂáª‰∫ã‰ª∂Â§ÑÁêÜ
            quizTabs.forEach(tab => {
                const popup = tab.querySelector('.quiz-popup');
                
                // ÁÇπÂáªÊ†áÁ≠æÂàáÊç¢ÈóÆÈ¢òÂç°ÁöÑÊòæÁ§∫Áä∂ÊÄÅ
                tab.addEventListener('click', function(e) {
                    e.stopPropagation(); // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°
                    
                    // Â¶ÇÊûúÂΩìÂâçÈóÆÈ¢òÂç°Â∑≤ÁªèÊòæÁ§∫ÔºåÂàôÈöêËóèÂÆÉ
                    if (popup.classList.contains('active')) {
                        popup.classList.remove('active');
                        backdrop.classList.remove('active');
                    } else {
                        // ÂÖàÈöêËóèÊâÄÊúâÂÖ∂‰ªñÈóÆÈ¢òÂç°
                        document.querySelectorAll('.quiz-popup').forEach(p => {
                            p.classList.remove('active');
                        });
                        
                        // Â∞ÜÂºπÁ™óÂÜÖÂÆπÂ§çÂà∂Âà∞È°µÈù¢ÊúÄÂ§ñÂ±ÇÁöÑÂºπÁ™ó‰∏≠
                        document.body.appendChild(popup);
                        
                        // ÊòæÁ§∫ÂΩìÂâçÈóÆÈ¢òÂç°ÂíåËÉåÊôØÈÅÆÁΩ©
                        popup.classList.add('active');
                        backdrop.classList.add('active');
                    }
                });
                
                // Á°Æ‰øùÁÇπÂáªÈóÆÈ¢òÂç°ÂÜÖÈÉ®Êó∂‰∏ç‰ºöÂÖ≥Èó≠ÈóÆÈ¢òÂç°
                popup.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            });
            
            // ÁÇπÂáªÈÅÆÁΩ©Â±ÇÊàñÈ°µÈù¢‰ªª‰ΩïÂÖ∂‰ªñ‰ΩçÁΩÆÊó∂ÈöêËóèÊâÄÊúâÈóÆÈ¢òÂç°
            backdrop.addEventListener('click', closeAllPopups);
            document.addEventListener('click', closeAllPopups);
            
            function closeAllPopups() {
                document.querySelectorAll('.quiz-popup').forEach(popup => {
                    popup.classList.remove('active');
                });
                backdrop.classList.remove('active');
            }
            
            // ‰∏∫ÊØè‰∏™ÈÄâÈ°πÊ∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂
            document.querySelectorAll('.quiz-choice').forEach(choice => {
                choice.addEventListener('click', function() {
                    const choiceContainer = this.closest('.quiz-choices');
                    const popupContainer = this.closest('.quiz-popup');
                    const feedbackElement = popupContainer.querySelector('.quiz-feedback');
                    const correctAnswer = popupContainer.getAttribute('data-answer');
                    
                    // ÈáçÁΩÆÊâÄÊúâÈÄâÈ°π
                    choiceContainer.querySelectorAll('.quiz-choice').forEach(c => {
                        c.classList.remove('selected', 'correct', 'incorrect');
                    });
                    
                    // Ê†áËÆ∞ÂΩìÂâçÈÄâÈ°π‰∏∫Â∑≤ÈÄâ
                    this.classList.add('selected');
                    
                    // Ê£ÄÊü•ÊòØÂê¶Ê≠£Á°Æ
                    if (this.getAttribute('data-value') === correctAnswer) {
                        this.classList.add('correct');
                        feedbackElement.textContent = '‚úîÔ∏è CorrectÔºÅ';
                        feedbackElement.classList.add('correct');
                        feedbackElement.classList.remove('incorrect');
                    } else {
                        this.classList.add('incorrect');
                        feedbackElement.textContent = '‚ùå WrongÔºÅ';
                        feedbackElement.classList.add('incorrect');
                        feedbackElement.classList.remove('correct');
                    }
                    
                    feedbackElement.style.display = 'block';
                });
            });
            
            // Âç°ÁâáËΩÆÊí≠ÂäüËÉΩ - Êñ∞Â¢û
            const cardDecks = document.querySelectorAll('.card-deck');
            
            cardDecks.forEach(cardDeck => {
                const cards = cardDeck.querySelectorAll('.paper-card');
                const counter = cardDeck.querySelector('.card-counter');
                let currentIndex = 0;
                const totalCards = cards.length;
                
                // Êõ¥Êñ∞ËÆ°Êï∞Âô®ÊòæÁ§∫
                function updateCounter() {
                    if (counter) {
                        counter.textContent = `${currentIndex + 1}/${totalCards}`;
                    }
                }
                
                // ÊòæÁ§∫ÊåáÂÆöÁ¥¢ÂºïÁöÑÂç°Áâá
                function showCard(index) {
                    // Â§ÑÁêÜÂæ™ÁéØ
                    if (index >= totalCards) index = 0;
                    if (index < 0) index = totalCards - 1;
                    
                    // Êõ¥Êñ∞ÂΩìÂâçÁ¥¢Âºï
                    currentIndex = index;
                    
                    // Êõ¥Êñ∞Âç°ÁâáÊòæÁ§∫
                    cards.forEach((card, i) => {
                        if (i === currentIndex) {
                            card.classList.add('active');
                        } else {
                            card.classList.remove('active');
                        }
                    });
                    
                    // Êõ¥Êñ∞ËÆ°Êï∞Âô®
                    updateCounter();
                }
                
                // ‰∏ã‰∏ÄÂº†Âç°Áâá
                function nextCard(e) {
                    e.stopPropagation(); // Èò≤Ê≠¢‰∫ã‰ª∂ÂÜíÊ≥°ÂØºËá¥ÈóÆÈ¢òÂç°ÂÖ≥Èó≠
                    showCard(currentIndex + 1);
                }
                
                // ‰∏∫ÊØè‰∏™Âç°ÁâáÊ∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂ÔºàËÄå‰∏çÊòØÊï¥‰∏™ÂÆπÂô®Ôºâ
                cards.forEach(card => {
                    card.addEventListener('click', function(e) {
                        // Âè™ÊúâÁÇπÂáªÂú®Âç°ÁâáÂÜÖÈÉ®Êó∂ÊâçÂàáÊç¢
                        // Ê£ÄÊü•ÊòØÂê¶ÊòØÊµÅÁ®ãÂõæÂç°ÁâáÁöÑÊªöÂä®Êù°Âå∫Âüü
                        if (this.classList.contains('flowchart-card')) {
                            const rect = this.getBoundingClientRect();
                            const isScrollbarClick =
                                (e.clientY >= rect.top && e.clientY <= rect.bottom && e.clientX >= rect.right - 20 && e.clientX <= rect.right) ||
                                (e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.bottom - 20 && e.clientY <= rect.bottom);

                            if (!isScrollbarClick) {
                                nextCard(e);
                            }
                        } else {
                            nextCard(e);
                        }
                    });
                });
                
                // ÈîÆÁõòÂØºËà™
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowRight') {
                        showCard(currentIndex + 1);
                    } else if (e.key === 'ArrowLeft') {
                        showCard(currentIndex - 1);
                    }
                });
            });
        });
    </script>

    <!-- AI Assistant Scripts - Load in correct order (relative paths for subpages) -->
    <script src="../../js/ai-assistant-constants.js"></script>
    <script src="../../js/ai-assistant-storage.js"></script>
    <script src="../../js/ai-assistant-positioning.js"></script>
    <script src="../../js/ai-assistant-templates.js"></script>
    <script src="../../js/ai-assistant-dom-utils.js"></script>
    <script src="../../js/ai-assistant-config.js"></script>
    <script src="../../js/ai-assistant.js"></script>
</body>
</html>
